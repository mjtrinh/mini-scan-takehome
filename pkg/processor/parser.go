package processor

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"time"
)

// ParseScanEnvelope converts the raw JSON payload generated by the scanner into
// a normalized ServiceScan struct.
func ParseScanEnvelope(data []byte) (*ServiceScan, error) {
	var envelope scanEnvelope
	if err := json.Unmarshal(data, &envelope); err != nil {
		return nil, fmt.Errorf("error decoding scan envelope: %w", err)
	}

	if envelope.IP == "" {
		return nil, fmt.Errorf("scan missing ip")
	}
	if envelope.Port == 0 {
		return nil, fmt.Errorf("scan missing port")
	}
	if envelope.Service == "" {
		return nil, fmt.Errorf("scan missing service")
	}
	if envelope.Timestamp == 0 {
		return nil, fmt.Errorf("scan missing timestamp")
	}

	response, err := decodeResponse(envelope.DataVersion, envelope.Data)
	if err != nil {
		return nil, err
	}

	scan := &ServiceScan{
		IP:         envelope.IP,
		Port:       envelope.Port,
		Service:    envelope.Service,
		ObservedAt: time.Unix(envelope.Timestamp, 0).UTC(),
		Response:   response,
	}

	return scan, nil
}

type scanEnvelope struct {
	IP          string          `json:"ip"`
	Port        uint32          `json:"port"`
	Service     string          `json:"service"`
	Timestamp   int64           `json:"timestamp"`
	DataVersion int             `json:"data_version"`
	Data        json.RawMessage `json:"data"`
}

func decodeResponse(version int, data json.RawMessage) (string, error) {
	switch version {
	case 1:
		var payload v1Payload
		if err := json.Unmarshal(data, &payload); err != nil {
			return "", fmt.Errorf("error decoding v1 payload: %w", err)
		}
		if payload.ResponseBytesUtf8 == "" {
			return "", fmt.Errorf("v1 payload missing response_bytes_utf8")
		}
		decoded, err := base64.StdEncoding.DecodeString(payload.ResponseBytesUtf8)
		if err != nil {
			return "", fmt.Errorf("error decoding v1 base64: %w", err)
		}
		return string(decoded), nil
	case 2:
		var payload v2Payload
		if err := json.Unmarshal(data, &payload); err != nil {
			return "", fmt.Errorf("error decoding v2 payload: %w", err)
		}
		if payload.ResponseStr == "" {
			return "", fmt.Errorf("v2 payload missing response_str")
		}
		return payload.ResponseStr, nil
	default:
		return "", fmt.Errorf("unsupported data_version %d", version)
	}
}

type v1Payload struct {
	ResponseBytesUtf8 string `json:"response_bytes_utf8"`
}

type v2Payload struct {
	ResponseStr string `json:"response_str"`
}
